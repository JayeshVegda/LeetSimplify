{
  "version": 1,
  "meta": {
    "name": "LeetSimplify Prompts and Preferences",
    "updatedAt": "2025-11-11T00:00:00.000Z"
  },
  "prompts": {
    "simplifyNoHint": "Rewrite this LeetCode problem in simple, easy-to-understand language while preserving EVERY single detail from the original problem. Translate technical terms to simple words but keep ALL information intact.\n\nCRITICAL - COMPLETENESS IS KEY:\n- Task section: Rewrite the ENTIRE problem statement in easy language. Include EVERY detail: what to find, what to do with inputs, all conditions that must be satisfied, all relationships between elements, all comparisons needed, all operations required, exact format of output, any special definitions or concepts. Do NOT simplify away any information - translate to easy words but keep everything.\n- Preserve ALL nuances: ordering requirements, comparison rules, equality conditions, inequality conditions, counting rules, selection criteria, transformation rules, validation rules\n- Include ALL constraints: input ranges, array/string sizes, value limits, time/space complexity if specified, memory limits, operation limits\n- State ALL edge cases explicitly: empty inputs, single elements, duplicates, negative numbers, zero values, ties, overflow cases, index boundaries (0-based vs 1-based), ordering requirements, rounding rules, boundary conditions, special character handling\n- Define ALL special terms: translate technical terms to simple words but explain them fully (e.g., 'subset' = 'a smaller group selected from the larger group', 'binary string' = 'a string made up of only 0s and 1s')\n- Specify exact formats: input types, output types, return formats, data structures, representation methods\n- NO solution approaches, strategies, algorithms, code, or hints - just the complete problem description in easy language\n\nFormat exactly as shown:\n\n1) Task:\n[Rewrite the COMPLETE problem statement in easy language. Start by explaining what the problem is asking in simple terms, then include EVERY requirement, condition, rule, and detail from the original problem. Use easy words but don't skip anything. If the original mentions 'find the maximum', say 'find the maximum' but explain what maximum means. If it mentions 'subset', explain what subset means. Include all conditions that must be checked, all comparisons that must be made, all calculations that must be performed. Be comprehensive and thorough - this should be the full problem just written in easier language.]\n\n2) Inputs:\n- [Input name 1]: [Type and detailed description - explain what this input represents, its format, any restrictions]\n- [Input name 2]: [Type and detailed description - explain what this input represents, its format, any restrictions]\n[Continue for all inputs with full details]\n\n3) Output:\n[What exactly needs to be returned - explain the format, type, and any specific requirements for the output]\n\n4) Key Rules & Constraints:\n- [Constraint 1 - list every constraint from the problem]\n- [Constraint 2 - include all input/output constraints]\n- [Constraint 3 - include all operational constraints]\n[Continue for ALL constraints - don't miss any]\n\n5) Edge Cases to Watch:\n- [Edge case 1 - list all edge cases explicitly]\n- [Edge case 2 - mention all boundary conditions]\n- [Edge case 3 - include all special scenarios]\n[Continue for ALL edge cases - be thorough]\n\n6) Example:\nInput:\n[Show actual input values clearly with exact format]\n\nOutput:\n[Show expected output with exact format]\n\nExplanation (Dry Run - Step by Step):\n[Provide a COMPLETE DRY RUN of the example. This should be extremely detailed, like you're manually executing the solution step-by-step.\n\nFormat the dry run like this:\n\nStep 1: [Initial setup - describe what we start with, list all inputs clearly]\nStep 2: [First operation - show exactly what we do, what we check, what we calculate]\nStep 3: [Second operation - continue with explicit details]\nStep 4: [Continue step by step...]\n\nFor each step, show:\n- What we're checking or processing\n- The exact values we're working with\n- Any calculations (show the math: 1+1=2, count: 3 elements, etc.)\n- Any comparisons (show: 5 > 3? Yes, so...)\n- Any conditions being verified\n- What we decide at each step and why\n- Current state after each step\n\nContinue until you reach the final answer, then:\n\nFinal Verification:\n- Count/verify the final result explicitly\n- Check it satisfies all constraints (show each constraint check)\n- Verify it meets all requirements from the problem\n- Explain why this is the correct answer and why other possibilities don't work\n- Show that this is indeed the optimal/correct solution]\n---",
    "simplifyWithHint": "Rewrite this LeetCode problem in simple, easy-to-understand language while preserving EVERY single detail from the original problem. Translate technical terms to simple words but keep ALL information intact.\n\nCRITICAL - COMPLETENESS IS KEY:\n- Task section: Rewrite the ENTIRE problem statement in easy language. Include EVERY detail: what to find, what to do with inputs, all conditions that must be satisfied, all relationships between elements, all comparisons needed, all operations required, exact format of output, any special definitions or concepts. Do NOT simplify away any information - translate to easy words but keep everything.\n- Preserve ALL nuances: ordering requirements, comparison rules, equality conditions, inequality conditions, counting rules, selection criteria, transformation rules, validation rules\n- Include ALL constraints: input ranges, array/string sizes, value limits, time/space complexity if specified, memory limits, operation limits\n- State ALL edge cases explicitly: empty inputs, single elements, duplicates, negative numbers, zero values, ties, overflow cases, index boundaries (0-based vs 1-based), ordering requirements, rounding rules, boundary conditions, special character handling\n- Define ALL special terms: translate technical terms to simple words but explain them fully (e.g., 'subset' = 'a smaller group selected from the larger group', 'binary string' = 'a string made up of only 0s and 1s')\n- Specify exact formats: input types, output types, return formats, data structures, representation methods\n- Add ONE gentle high-level thinking hint at the end (no code, no algorithm steps, no implementation details)\n\nFormat exactly as shown:\n\n1) Task:\n[Rewrite the COMPLETE problem statement in easy language. Start by explaining what the problem is asking in simple terms, then include EVERY requirement, condition, rule, and detail from the original problem. Use easy words but don't skip anything. If the original mentions 'find the maximum', say 'find the maximum' but explain what maximum means. If it mentions 'subset', explain what subset means. Include all conditions that must be checked, all comparisons that must be made, all calculations that must be performed. Be comprehensive and thorough - this should be the full problem just written in easier language.]\n\n2) Inputs:\n- [Input name 1]: [Type and detailed description - explain what this input represents, its format, any restrictions]\n- [Input name 2]: [Type and detailed description - explain what this input represents, its format, any restrictions]\n[Continue for all inputs with full details]\n\n3) Output:\n[What exactly needs to be returned - explain the format, type, and any specific requirements for the output]\n\n4) Key Rules & Constraints:\n- [Constraint 1 - list every constraint from the problem]\n- [Constraint 2 - include all input/output constraints]\n- [Constraint 3 - include all operational constraints]\n[Continue for ALL constraints - don't miss any]\n\n5) Edge Cases to Watch:\n- [Edge case 1 - list all edge cases explicitly]\n- [Edge case 2 - mention all boundary conditions]\n- [Edge case 3 - include all special scenarios]\n[Continue for ALL edge cases - be thorough]\n\n6) Example:\nInput:\n[Show actual input values clearly with exact format]\n\nOutput:\n[Show expected output with exact format]\n\nExplanation (Dry Run - Step by Step):\n[Provide a COMPLETE DRY RUN of the example. This should be extremely detailed, like you're manually executing the solution step-by-step.\n\nFormat the dry run like this:\n\nStep 1: [Initial setup - describe what we start with, list all inputs clearly]\nStep 2: [First operation - show exactly what we do, what we check, what we calculate]\nStep 3: [Second operation - continue with explicit details]\nStep 4: [Continue step by step...]\n\nFor each step, show:\n- What we're checking or processing\n- The exact values we're working with\n- Any calculations (show the math: 1+1=2, count: 3 elements, etc.)\n- Any comparisons (show: 5 > 3? Yes, so...)\n- Any conditions being verified\n- What we decide at each step and why\n- Current state after each step\n\nContinue until you reach the final answer, then:\n\nFinal Verification:\n- Count/verify the final result explicitly\n- Check it satisfies all constraints (show each constraint check)\n- Verify it meets all requirements from the problem\n- Explain why this is the correct answer and why other possibilities don't work\n- Show that this is indeed the optimal/correct solution]\n\n7) Hint:\n[One gentle, high-level thinking nudge - no code, no algorithm steps, no implementation details, just a conceptual hint about how to approach the problem]\n---"
  },
  "preferences": {
    "defaultProvider": "gemini",
    "ui": {
      "showFloatingButton": true,
      "theme": "auto",
      "fontFamily": "JetBrains Mono"
    },
    "generation": {
      "temperature": 0.3,
      "maxTokens": 2048,
      "defaultMode": "noHint", 
      "retryOnEmpty": true
    },
    "providers": {
      "gemini": { "model": "gemini-2.5-flash" },
      "openai": { "model": "gpt-4o-mini" },
      "anthropic": { "model": "claude-3-5-sonnet-latest" },
      "cohere": { "model": "command-r-plus" },
      "mistral": { "model": "mistral-large-latest" },
      "local": { "model": "mistral", "endpoint": "http://127.0.0.1:11434/v1/chat/completions" }
    }
  }
}

