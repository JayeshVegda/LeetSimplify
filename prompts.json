{
  "version": 1,
  "meta": {
    "name": "LeetSimplify Prompts and Preferences",
    "updatedAt": "2025-11-11T00:00:00.000Z"
  },
  "prompts": {
    "simplifyNoHint": "Rewrite this LeetCode problem in simple, easy-to-understand language while preserving EVERY single detail from the original problem. Translate technical terms to simple words but keep ALL information intact.\n\nCRITICAL - COMPLETENESS IS KEY:\n- Task section: Rewrite the ENTIRE problem statement in easy language. Include EVERY detail: what to find, what to do with inputs, all conditions that must be satisfied, all relationships between elements, all comparisons needed, all operations required, exact format of output, any special definitions or concepts. Do NOT simplify away any information - translate to easy words but keep everything.\n- Preserve ALL nuances: ordering requirements, comparison rules, equality conditions, inequality conditions, counting rules, selection criteria, transformation rules, validation rules\n- Include ALL constraints: input ranges, array/string sizes, value limits, time/space complexity if specified, memory limits, operation limits\n- State ALL edge cases explicitly: empty inputs, single elements, duplicates, negative numbers, zero values, ties, overflow cases, index boundaries (0-based vs 1-based), ordering requirements, rounding rules, boundary conditions, special character handling\n- Define ALL special terms: translate technical terms to simple words but explain them fully (e.g., 'subset' = 'a smaller group selected from the larger group', 'binary string' = 'a string made up of only 0s and 1s')\n- Specify exact formats: input types, output types, return formats, data structures, representation methods\n- NO solution approaches, strategies, algorithms, code, or hints - just the complete problem description in easy language\n\nFormat exactly as shown:\n\n1) Task:\n[Rewrite the COMPLETE problem statement in easy language. Start by explaining what the problem is asking in simple terms, then include EVERY requirement, condition, rule, and detail from the original problem. Use easy words but don't skip anything. If the original mentions 'find the maximum', say 'find the maximum' but explain what maximum means. If it mentions 'subset', explain what subset means. Include all conditions that must be checked, all comparisons that must be made, all calculations that must be performed. Be comprehensive and thorough - this should be the full problem just written in easier language.]\n\n2) Inputs:\n- [Input name 1]: [Type and detailed description - explain what this input represents, its format, any restrictions]\n- [Input name 2]: [Type and detailed description - explain what this input represents, its format, any restrictions]\n[Continue for all inputs with full details]\n\n3) Output:\n[What exactly needs to be returned - explain the format, type, and any specific requirements for the output]\n\n4) Key Rules & Constraints:\n- [Constraint 1 - list every constraint from the problem]\n- [Constraint 2 - include all input/output constraints]\n- [Constraint 3 - include all operational constraints]\n[Continue for ALL constraints - don't miss any]\n\n5) Edge Cases to Watch:\n- [Edge case 1 - list all edge cases explicitly]\n- [Edge case 2 - mention all boundary conditions]\n- [Edge case 3 - include all special scenarios]\n[Continue for ALL edge cases - be thorough]\n\n6) Example:\nInput:\n[Show actual input values clearly with exact format]\n\nOutput:\n[Show expected output with exact format]\n\nExplanation (Dry Run - Step by Step):\n[Provide a COMPLETE DRY RUN of the example. This should be extremely detailed, like you're manually executing the solution step-by-step.\n\nFormat the dry run like this:\n\nStep 1: [Initial setup - describe what we start with, list all inputs clearly]\nStep 2: [First operation - show exactly what we do, what we check, what we calculate]\nStep 3: [Second operation - continue with explicit details]\nStep 4: [Continue step by step...]\n\nFor each step, show:\n- What we're checking or processing\n- The exact values we're working with\n- Any calculations (show the math: 1+1=2, count: 3 elements, etc.)\n- Any comparisons (show: 5 > 3? Yes, so...)\n- Any conditions being verified\n- What we decide at each step and why\n- Current state after each step\n\nContinue until you reach the final answer, then:\n\nFinal Verification:\n- Count/verify the final result explicitly\n- Check it satisfies all constraints (show each constraint check)\n- Verify it meets all requirements from the problem\n- Explain why this is the correct answer and why other possibilities don't work\n- Show that this is indeed the optimal/correct solution]\n---",
    "simplifyWithHint": "Rewrite this LeetCode problem in simple, easy-to-understand language while preserving EVERY single detail from the original problem. Translate technical terms to simple words but keep ALL information intact.\n\nCRITICAL - COMPLETENESS IS KEY:\n- Task section: Rewrite the ENTIRE problem statement in easy language. Include EVERY detail: what to find, what to do with inputs, all conditions that must be satisfied, all relationships between elements, all comparisons needed, all operations required, exact format of output, any special definitions or concepts. Do NOT simplify away any information - translate to easy words but keep everything.\n- Preserve ALL nuances: ordering requirements, comparison rules, equality conditions, inequality conditions, counting rules, selection criteria, transformation rules, validation rules\n- Include ALL constraints: input ranges, array/string sizes, value limits, time/space complexity if specified, memory limits, operation limits\n- State ALL edge cases explicitly: empty inputs, single elements, duplicates, negative numbers, zero values, ties, overflow cases, index boundaries (0-based vs 1-based), ordering requirements, rounding rules, boundary conditions, special character handling\n- Define ALL special terms: translate technical terms to simple words but explain them fully (e.g., 'subset' = 'a smaller group selected from the larger group', 'binary string' = 'a string made up of only 0s and 1s')\n- Specify exact formats: input types, output types, return formats, data structures, representation methods\n- Add detailed hints at the end including problem category, suggested data structures, key methods/techniques, high-level strategy, and complexity considerations (no code or exact algorithm steps, but provide helpful guidance)\n\nFormat exactly as shown:\n\n1) Task:\n[Rewrite the COMPLETE problem statement in easy language. Start by explaining what the problem is asking in simple terms, then include EVERY requirement, condition, rule, and detail from the original problem. Use easy words but don't skip anything. If the original mentions 'find the maximum', say 'find the maximum' but explain what maximum means. If it mentions 'subset', explain what subset means. Include all conditions that must be checked, all comparisons that must be made, all calculations that must be performed. Be comprehensive and thorough - this should be the full problem just written in easier language.]\n\n2) Inputs:\n- [Input name 1]: [Type and detailed description - explain what this input represents, its format, any restrictions]\n- [Input name 2]: [Type and detailed description - explain what this input represents, its format, any restrictions]\n[Continue for all inputs with full details]\n\n3) Output:\n[What exactly needs to be returned - explain the format, type, and any specific requirements for the output]\n\n4) Key Rules & Constraints:\n- [Constraint 1 - list every constraint from the problem]\n- [Constraint 2 - include all input/output constraints]\n- [Constraint 3 - include all operational constraints]\n[Continue for ALL constraints - don't miss any]\n\n5) Edge Cases to Watch:\n- [Edge case 1 - list all edge cases explicitly]\n- [Edge case 2 - mention all boundary conditions]\n- [Edge case 3 - include all special scenarios]\n[Continue for ALL edge cases - be thorough]\n\n6) Example:\nInput:\n[Show actual input values clearly with exact format]\n\nOutput:\n[Show expected output with exact format]\n\nExplanation (Dry Run - Step by Step):\n[Provide a COMPLETE DRY RUN of the example. This should be extremely detailed, like you're manually executing the solution step-by-step.\n\nFormat the dry run like this:\n\nStep 1: [Initial setup - describe what we start with, list all inputs clearly]\nStep 2: [First operation - show exactly what we do, what we check, what we calculate]\nStep 3: [Second operation - continue with explicit details]\nStep 4: [Continue step by step...]\n\nFor each step, show:\n- What we're checking or processing\n- The exact values we're working with\n- Any calculations (show the math: 1+1=2, count: 3 elements, etc.)\n- Any comparisons (show: 5 > 3? Yes, so...)\n- Any conditions being verified\n- What we decide at each step and why\n- Current state after each step\n\nContinue until you reach the final answer, then:\n\nFinal Verification:\n- Count/verify the final result explicitly\n- Check it satisfies all constraints (show each constraint check)\n- Verify it meets all requirements from the problem\n- Explain why this is the correct answer and why other possibilities don't work\n- Show that this is indeed the optimal/correct solution]\n\n7) Hint:\n[Provide detailed guidance to help solve the problem. Include:\n\n- Problem Category/Topic: Identify the main algorithmic topic or category this problem belongs to (e.g., Array/Two Pointers, String Manipulation, Hash Table, Dynamic Programming, Greedy, Graph Traversal, Tree, Binary Search, Sliding Window, Stack/Queue, Backtracking, etc.)\n\n- Suggested Data Structures: Recommend which data structures would be helpful (e.g., Array, Hash Map/Set, Stack, Queue, Priority Queue/Heap, Tree, Graph, Trie, Union-Find, etc.) and briefly explain why they might be useful for this problem\n\n- Key Methods/Techniques: Suggest specific techniques or approaches that could be applied (e.g., Two Pointers, Sliding Window, Prefix Sum, Binary Search, DFS/BFS, Memoization, Sorting, Greedy Choice, etc.) and explain when/how they might help\n\n- High-Level Strategy: Provide a gentle conceptual hint about the overall approach or pattern to think about (e.g., \"Think about how you can track elements as you iterate\", \"Consider what information you need to remember from previous steps\", \"Try to break this into smaller subproblems\", etc.)\n\n- Time/Space Complexity Considerations: Mention any important complexity constraints or optimizations to keep in mind (e.g., \"This can be solved in O(n) time with O(1) extra space\", \"Consider if you can use extra space to trade for better time complexity\", etc.)\n\nKeep it educational and guiding - suggest tools and approaches without giving away the exact solution steps or code implementation]\n---"
  },
  "preferences": {
    "defaultProvider": "gemini",
    "ui": {
      "showFloatingButton": true,
      "theme": "auto",
      "fontFamily": "JetBrains Mono"
    },
    "generation": {
      "temperature": 0.3,
      "maxTokens": 2048,
      "defaultMode": "noHint", 
      "retryOnEmpty": true
    },
    "providers": {
      "gemini": { "model": "gemini-2.5-flash" },
      "openai": { "model": "gpt-4o-mini" },
      "anthropic": { "model": "claude-3-5-sonnet-latest" },
      "cohere": { "model": "command-r-plus" },
      "mistral": { "model": "mistral-large-latest" },
      "local": { "model": "mistral", "endpoint": "http://127.0.0.1:11434/v1/chat/completions" }
    }
  }
}

